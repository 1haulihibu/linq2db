<#@ assembly name="System.Core"                   #>
<#@ import namespace="System"                     #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq"                #>
<#+
static Action<GeneratedTextTransformation,string> WriteComment = (tt,s) => tt.WriteLine("//{0}", s);

void GenerateModel()
{
	if (GenerationEnvironment.Length > 0 && GenerationEnvironment.ToString().Trim().Length == 0)
		GenerationEnvironment.Length = 0;

	WriteComment(this, "---------------------------------------------------------------------------------------------------");
	WriteComment(this, " <auto-generated>");
	WriteComment(this, "    This code was generated by T4Model template for T4 (https://github.com/igor-tkachev/t4models).");
	WriteComment(this, "    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
	WriteComment(this, " </auto-generated>");
	WriteComment(this, "---------------------------------------------------------------------------------------------------");

	Source.Render(this);
}

void Trim()
{
	var arr = new[] { '\r', '\n', ' ' };
	while (GenerationEnvironment.Length > 0 && arr.Contains(GenerationEnvironment[GenerationEnvironment.Length - 1]))
		GenerationEnvironment.Length--;

	WriteLine("");
}

static Action<GeneratedTextTransformation,string> WriteUsing = (tt,s) => tt.WriteLine("using {0};", s);

void RenderUsings(List<string> usings)
{
	var q =
		from ns in usings.Distinct()
		group ns by ns.Split('.')[0];

	var groups =
		(from ns in q where ns.Key == "System"                select ns).Concat
		(from ns in q where ns.Key != "System" orderby ns.Key select ns);

	foreach (var gr in groups)
	{
		foreach (var ns in from s in gr orderby s select s)
			WriteUsing(this, ns);

		WriteLine("");
	}

	Trim();
}

// Base data types.
//
SourceUnit Source = new SourceUnit();

public partial class SourceUnit
{
	public List<string>    Usings     = new List<String>    { "System"        };
	public List<Namespace> Namespaces = new List<Namespace> { new Namespace() };

	public virtual void Render(GeneratedTextTransformation tt)
	{
		tt.RenderUsings(Usings);
		tt.WriteLine("");

		foreach (var nm in Namespaces)
		{
			nm.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();
	}
}

static Action<GeneratedTextTransformation,string> WriteBeginNamespace = (tt,s) => { tt.WriteLine("namespace {0}", s); tt.WriteLine("{"); };
static Action<GeneratedTextTransformation>        WriteEndNamespace   =  tt    => tt.WriteLine("}");

public partial class Namespace
{
	public string         Name;
	public List<TypeBase> Types = new List<TypeBase>();

	public virtual void Render(GeneratedTextTransformation tt)
	{
		if (!string.IsNullOrEmpty(Name))
		{
			WriteBeginNamespace(tt, Name);
			tt.PushIndent("\t");
		}

		foreach (var t in Types)
		{
			t.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Name))
		{
			tt.PopIndent();
			WriteEndNamespace(tt);
		}
	}
}

public enum AccessModifier
{
	Public,
	Protected,
	Internal,
	Private
}

public abstract partial class TypeBase
{
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public List<Attribute> Attributes = new List<Attribute>();

	public abstract void Render(GeneratedTextTransformation tt);
}

static Action<GeneratedTextTransformation,Class> WriteBeginClass = (tt,cl) =>
{
	tt.Write(cl.AccessModifier.ToString().ToLower() + " ");
	tt.Write("partial class {0}", cl.Name);
	
	if (!string.IsNullOrEmpty(cl.BaseClass) || cl.Interfaces.Count > 0)
	{
		var arr = new[] { cl.BaseClass }.Concat(cl.Interfaces)
			.Where(n => n != null)
			.ToArray();
		
		tt.Write(" : ");
		tt.Write(string.Join(", ", arr));
	}

	tt.WriteLine("");
	tt.WriteLine("{");
};

static Action<GeneratedTextTransformation> WriteEndClass = tt => tt.WriteLine("}");

public partial class Class : TypeBase
{
	public string           BaseClass;
	public List<string>     Interfaces = new List<string>();
	public List<MemberBase> Members    = new List<MemberBase>();

	public override void Render(GeneratedTextTransformation tt)
	{
		if (Attributes.Count > 0)
		{
			tt.Write("[");
			
			for (var i = 0; i < Attributes.Count; i++)
			{
				if (i > 0) tt.Write(", ");
				Attributes[i].Render(tt);
			}

			tt.WriteLine("]");
		}

		WriteBeginClass(tt, this);
		tt.PushIndent("\t");

		foreach (var m in Members)
		{
			if (m.Attributes.Count > 0)
			{
				tt.Write("[");
				
				for (var i = 0; i < m.Attributes.Count; i++)
				{
					if (i > 0) tt.Write(", ");
					m.Attributes[i].Render(tt);
				}

				tt.WriteLine("]");
			}
			
			m.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();

		tt.PopIndent();
		WriteEndClass(tt);
	}
}

public abstract partial class MemberBase
{
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public string          Type;
	public string          EndLineComment;
	public List<Attribute> Attributes = new List<Attribute>();

	public int AccessModifierLen;
	public int NameLen;
	public int TypeLen;

	public abstract void Render(GeneratedTextTransformation tt);
}

static Action<GeneratedTextTransformation,string> BeginRegion = (tt,s) => { tt.WriteLine("#region {0}", s); };
static Action<GeneratedTextTransformation>        EndRegion   = (tt)   => { tt.WriteLine("#endregion");     };

public partial class MemberGroup : MemberBase
{
	public string           Region;
	public bool             IsCompact;
	public List<MemberBase> Members = new List<MemberBase>();

	public override void Render(GeneratedTextTransformation tt)
	{
		if (!string.IsNullOrEmpty(Region))
		{
			BeginRegion(tt, Region);
			tt.WriteLine("");
		}

		if (IsCompact)
		{
			var allMembers = GetAllMembers().ToList();
			
			if (allMembers.Count > 0)
			{
				int max = allMembers.Max(m => m.AccessModifier.ToString().Length);

				foreach (var m in allMembers)
					m.AccessModifierLen = max;
				
				max = allMembers.Max(m => m.Type.Length);

				foreach (var m in allMembers)
					m.TypeLen = max;

				var notHasGetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasGetter);
				var notHasSetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasSetter);

				max = allMembers.Max(m =>
				{
					var n = m.Name.Length;
					
					if (m is Field)
						n += 1;  // ';'
					else if (m is Property)
					{
						var p = (Property)m;
						
						if (p.IsAuto)
							n += (4 + (p.HasGetter ? 5 : 13) +  + (p.HasSetter ? 5 : 13)); // ' { get; set; }'
					}
					
					return n;
				});

				foreach (var m in allMembers)
					m.NameLen = max;

				foreach (var p in allMembers.OfType<Property>())
				{
					if (notHasGetter) p.GetterLen = 13;
					if (notHasSetter) p.SetterLen = 13;
				}
			}
		}

		foreach (var m in Members)
		{
			if (!IsCompact && m.Attributes.Count > 0)
			{
				tt.Write("[");
				
				for (var i = 0; i < m.Attributes.Count; i++)
				{
					if (i > 0) tt.Write(", ");
					m.Attributes[i].Render(tt);
				}

				tt.WriteLine("]");
			}
			
			m.Render(tt);

			if (!IsCompact)
				tt.WriteLine("");
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Region))
		{
			tt.WriteLine("");
			EndRegion(tt);
		}
	}

	IEnumerable<MemberBase> GetAllMembers()
	{
		foreach (var m in Members)
		{
			if (m is MemberGroup)
				foreach (var gm in ((MemberGroup)m).GetAllMembers())
					yield return gm;
			else
				yield return m;
		}
	}
}

static Action<GeneratedTextTransformation,Field> WriteField = (tt,f) =>
{
	var am = f.AccessModifier.ToString().ToLower();

	tt.Write("{0}{1} {2}{3} {4};",
		am,     LenDiff(f.AccessModifierLen, am),
		f.Type, LenDiff(f.TypeLen,           f.Type),
		f.Name);
	
	if (!string.IsNullOrEmpty(f.EndLineComment))
	{
		tt.Write(" " + LenDiff(f.NameLen - 1, f.Name));
		WriteComment(tt, " " + f.EndLineComment);
	}
	else	
		tt.WriteLine("");
};

public partial class Field : MemberBase
{
	public Field()
	{
	}
	
	public Field(string type, string name)
	{
		Type = type;
		Name = name;
	}
	
	public override void Render(GeneratedTextTransformation tt)
	{
		WriteField(tt, this);
	}
}

static Action<GeneratedTextTransformation,Property> WriteProperty = (tt,p) =>
{
	var am = p.AccessModifier.ToString().ToLower();

	tt.Write("{0}{1} {2}{3} {4}",
		am,     LenDiff(p.AccessModifierLen, am),
		p.Type, LenDiff(p.TypeLen,           p.Type),
		p.Name);

	if (p.IsAuto)
	{
		tt.Write(LenDiff(p.NameLen - (4 + p.GetterLen + p.SetterLen), p.Name));

		tt.Write(" { ");
		
		if (!p.HasGetter)
			tt.Write("private ");
		else if (p.GetterLen == 13)
			tt.Write("        ");
		tt.Write("get; ");

		if (!p.HasSetter)
			tt.Write("private ");
		else if (p.SetterLen == 13)
			tt.Write("        ");
		tt.Write("set; ");
		
		tt.Write("}");
	}
	
	if (!string.IsNullOrEmpty(p.EndLineComment))
	{
		tt.Write(" ");
		if (!p.IsAuto)
			tt.Write(LenDiff(p.NameLen, p.Name));
		WriteComment(tt, " " + p.EndLineComment);
	}
	else	
		tt.WriteLine("");
};

public partial class Property : MemberBase
{
	public bool IsAuto    = true;
	public bool HasGetter = true;
	public bool HasSetter = true;

	public int GetterLen = 5;
	public int SetterLen = 5;
	
	public Property()
	{
	}
	
	public Property(string type, string name)
	{
		Type = type;
		Name = name;
	}
	
	public override void Render(GeneratedTextTransformation tt)
	{
		WriteProperty(tt, this);
	}
}

static Action<GeneratedTextTransformation,Attribute> WriteAttribute = (tt,a) =>
{
	tt.Write(a.Name);

	if (a.Parameters.Count > 0)
	{
		tt.Write("(");
		tt.Write(string.Join(", ", a.Parameters.ToArray()));
		tt.Write(")");		
	}
};

public partial class Attribute
{
	public string       Name;
	public List<string> Parameters = new List<string>();

	public virtual void Render(GeneratedTextTransformation tt)
	{
		WriteAttribute(tt, this);
	}
}

// Helpers.
//

static string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

void WriteSpace(int len)
{
	while (len-- > 0)
		Write(" ");
}

#>
