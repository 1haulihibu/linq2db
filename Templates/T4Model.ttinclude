<#@ assembly name="System.Core"                   #>
<#@ import namespace="System"                     #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq"                #>
<#+
static Action<GeneratedTextTransformation,string> WriteComment = (tt,s) => tt.WriteLine("//{0}", s);

void GenerateModel()
{
	if (GenerationEnvironment.Length > 0 && GenerationEnvironment.ToString().Trim().Length == 0)
		GenerationEnvironment.Length = 0;

	WriteComment(this, "---------------------------------------------------------------------------------------------------");
	WriteComment(this, " <auto-generated>");
	WriteComment(this, "    This code was generated by T4Model template for T4 (http://github.com/igor-tkachev/t4models).");
	WriteComment(this, "    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
	WriteComment(this, " </auto-generated>");
	WriteComment(this, "---------------------------------------------------------------------------------------------------");

	Source.Render(this);
}

void Trim()
{
	var arr = new[] { '\r', '\n', ' ' };
	while (GenerationEnvironment.Length > 0 && arr.Contains(GenerationEnvironment[GenerationEnvironment.Length - 1]))
		GenerationEnvironment.Length--;

	WriteLine("");
}

static Action<GeneratedTextTransformation,string> WriteUsing = (tt,s) => tt.WriteLine("using {0};", s);

void RenderUsings(List<string> usings)
{
	var q =
		from ns in usings.Distinct()
		group ns by ns.Split('.')[0];

	var groups =
		(from ns in q where ns.Key == "System"                select ns).Concat
		(from ns in q where ns.Key != "System" orderby ns.Key select ns);

	foreach (var gr in groups)
	{
		foreach (var ns in from s in gr orderby s select s)
			WriteUsing(this, ns);

		WriteLine("");
	}

	Trim();
}

// Base data types.
//
SourceUnit Source = new SourceUnit();

public partial class SourceUnit
{
	public List<string>    Usings     = new List<String>    { "System"        };
	public List<Namespace> Namespaces = new List<Namespace> { new Namespace() };

	public virtual void Render(GeneratedTextTransformation tt)
	{
		tt.RenderUsings(Usings);
		tt.WriteLine("");

		foreach (var nm in Namespaces)
		{
			nm.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();
	}
}

static Action<GeneratedTextTransformation,string> WriteBeginNamespace = (tt,s) => { tt.WriteLine("namespace {0}", s); tt.WriteLine("{"); };
static Action<GeneratedTextTransformation>        WriteEndNamespace   =  tt    => tt.WriteLine("}");

public partial class Namespace
{
	public string         Name;
	public List<TypeBase> Types = new List<TypeBase>();

	public virtual void Render(GeneratedTextTransformation tt)
	{
		if (!string.IsNullOrEmpty(Name))
		{
			WriteBeginNamespace(tt, Name);
			tt.PushIndent("\t");
		}

		foreach (var t in Types)
		{
			t.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Name))
		{
			tt.PopIndent();
			WriteEndNamespace(tt);
		}
	}
}

public enum AccessModifier
{
	Public,
	Protected,
	Internal,
	Private
}

public abstract partial class TypeBase
{
	public AccessModifier AccessModifier = AccessModifier.Public;
	public string         Name;

	public abstract void Render(GeneratedTextTransformation tt);
}

static Action<GeneratedTextTransformation,Class> WriteBeginClass = (tt,cl) =>
{
	tt.Write(cl.AccessModifier.ToString().ToLower() + " ");
	tt.Write("partial class {0}", cl.Name);
	if (!string.IsNullOrEmpty(cl.BaseClass))
		tt.Write(" : {0}", cl.BaseClass);
	tt.WriteLine("");
	tt.WriteLine("{");
};

static Action<GeneratedTextTransformation> WriteEndClass = tt => tt.WriteLine("}");

public partial class Class : TypeBase
{
	public string           BaseClass;
	public List<MemberBase> Members = new List<MemberBase>();

	public override void Render(GeneratedTextTransformation tt)
	{
		WriteBeginClass(tt, this);
		tt.PushIndent("\t");

		foreach (var m in Members)
		{
			m.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();

		tt.PopIndent();
		WriteEndClass(tt);
	}
}

public abstract partial class MemberBase
{
	public AccessModifier AccessModifier = AccessModifier.Public;
	public string         Name;
	public string         Type;
	public string         EndLineComment;

	public int AccessModifierLen;
	public int NameLen;
	public int TypeLen;

	public abstract void Render(GeneratedTextTransformation tt);
}

static Action<GeneratedTextTransformation,string> BeginRegion = (tt,s) => { tt.WriteLine("#region {0}", s); };
static Action<GeneratedTextTransformation>        EndRegion   = (tt)   => { tt.WriteLine("#endregion");     };

public partial class MemberGroup : MemberBase
{
	public bool             IsCompact;
	public List<MemberBase> Members = new List<MemberBase>();

	public override void Render(GeneratedTextTransformation tt)
	{
		if (!string.IsNullOrEmpty(Name))
		{
			BeginRegion(tt, Name);
			tt.WriteLine("");
		}

		if (IsCompact)
		{
			var allMembers = GetAllMembers().ToList();
			
			if (allMembers.Count > 0)
			{
				int max;

				max = allMembers.Max(m => m.AccessModifier.ToString().Length); foreach (var m in allMembers) m.AccessModifierLen = max;
				max = allMembers.Max(m => m.Type.Length);                      foreach (var m in allMembers) m.TypeLen           = max;
				max = allMembers.Max(m => m.Name.Length);                      foreach (var m in allMembers) m.NameLen           = max;
			}
		}

		foreach (var m in Members)
		{
			m.Render(tt);

			if (!IsCompact)
				tt.WriteLine("");
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Name))
		{
			tt.WriteLine("");
			EndRegion(tt);
		}
	}

	IEnumerable<MemberBase> GetAllMembers()
	{
		foreach (var m in Members)
		{
			if (m is MemberGroup)
				foreach (var gm in ((MemberGroup)m).GetAllMembers())
					yield return gm;
			else
				yield return m;
		}
	}
}

static Action<GeneratedTextTransformation,Field> WriteField = (tt,f) =>
{
	var am = f.AccessModifier.ToString().ToLower();

	tt.Write("{0}{1} {2}{3} {4};",
		am,     LenDiff(f.AccessModifierLen, am),
		f.Type, LenDiff(f.TypeLen,           f.Type),
		f.Name);
	
	if (!string.IsNullOrEmpty(f.EndLineComment))
	{
		tt.Write(" " + LenDiff(f.NameLen, f.Name));
		WriteComment(tt, " " + f.EndLineComment);
	}
	else	
		tt.WriteLine("");
};

public partial class Field : MemberBase
{
	public Field()
	{
	}
	
	public Field(string type, string name)
	{
		Type = type;
		Name = name;
	}
	
	public override void Render(GeneratedTextTransformation tt)
	{
		WriteField(tt, this);
	}
}

public partial class Attribute
{
	public string       Name;
	public List<string> Parameters = new List<string>();
}

// Helpers.
//

static string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

void WriteSpace(int len)
{
	while (len-- > 0)
		Write(" ");
}

#>
