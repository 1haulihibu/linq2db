<#@ assembly name="System.Data"      #>
<#@ import namespace="System.Data"   #>
<#@ import namespace="LinqToDB.Data" #>
<#@ include file="T4Model.ttinclude" #>
<#
	{
		var beforeGenerateModel = BeforeGenerateModel;
		BeforeGenerateModel = () =>
		{
			GenerateTypesFromMetadata();
			beforeGenerateModel();
		};
	}
#>
<#+

string   NamespaceName
{
	get { return Model.Namespace.Name;  }
	set { Model.Namespace.Name = value; }
}

string   DatabaseName             = null;
string   DataContextName          = null;
string   BaseDataContextClass     = "LinqToDB.Data.DataConnection";
string   BaseEntityClass          = null;
string   OneToManyAssociationType = "IEnumerable<{0}>";

string   OwnerToInclude           = null;
string[] DatabaseQuote            = null;

bool     RenderField              = false;
bool     RenderBackReferences     = true;
bool     RenderForeignKeys        = true;

Class    DataContextObject;

bool PluralizeClassNames                 = false;
bool SingularizeClassNames               = true;
bool PluralizeDataContextPropertyNames   = true;
bool SingularizeDataContextPropertyNames = false;

void LoadServerMetadata(DataConnection dataConnection)
{
	var sp = dataConnection.DataProvider.GetSchemaProvider();
	var db = sp.GetSchema(dataConnection);

	if (DataContextName == null)
		DataContextObject.Name = DataContextName = db.Database + "DB";

	DataContextObject.Comment.Add("/ <summary>");
	DataContextObject.Comment.Add("/ Database       : " + db.Database);
	DataContextObject.Comment.Add("/ Data Source    : " + db.DataSource);
	DataContextObject.Comment.Add("/ Server Version : " + db.ServerVersion);
	DataContextObject.Comment.Add("/ </summary>");

	var tables = db.Tables
		.Select(t => new
		{
			t,
			key = t.IsDefaultSchema ? t.TableName : t.SchemaName + "." + t.TableName,
			table = new Table
			{
				Schema                  = t.IsDefaultSchema ? null : t.SchemaName,
				BaseClass               = BaseEntityClass,
				TableName               = t.TableName,
				TypeName                =
					PluralizeClassNames   ? ToPlural  (t.TypeName) :
					SingularizeClassNames ? ToSingular(t.TypeName) : t.TypeName,
				DataContextPropertyName =
					PluralizeDataContextPropertyNames   ? ToPlural  (t.TypeName) :
					SingularizeDataContextPropertyNames ? ToSingular(t.TypeName) : t.TypeName,
				IsView                  = t.IsView,
				Description             = t.Description,
				Columns                 = t.Columns.ToDictionary(
					c => c.ColumnName,
					c => new Column
					{
						ColumnName      = c.ColumnName,
						ColumnType      = c.ColumnType,
						IsNullable      = c.IsNullable,
						IsIdentity      = c.IsIdentity,
						IsPrimaryKey    = c.IsPrimaryKey,
						PrimaryKeyOrder = c.PrimaryKeyOrder,
						MemberName      = CheckType(c.SystemType, c.MemberName),
						Type            = c.MemberType,
						SkipOnInsert    = c.SkipOnInsert,
						SkipOnUpdate    = c.SkipOnUpdate,
						Description     = c.Description,
					})
			}
		})
		.ToList();

	foreach (var t in tables)
		Tables.Add(t.key, t.table);

	var keys =
	(
		from t in tables
		from k in t.t.ForeignKeys
		let otherTable = tables.Where(tbl => tbl.t == k.OtherTable).Select(tbl => tbl.table).Single()
		select new
		{
			k,
			k.KeyName,
			t,
			key = new ForeignKey
			{
				KeyName         = k.KeyName,
				OtherTable      = otherTable,
				OtherColumns    = k.OtherColumns.Select(c => otherTable.Columns[c.ColumnName]).ToList(),
				ThisColumns     = k.ThisColumns. Select(c => t.table.   Columns[c.ColumnName]).ToList(),
				CanBeNull       = k.CanBeNull,
				MemberName      = k.MemberName,
				AssociationType = (AssociationType)(int)k.AssociationType,
			}
		}
	).ToList();

	foreach (var key in keys)
	{
		key.t.table.ForeignKeys.Add(key.KeyName, key.key);

		if (key.k.BackReference != null)
			key.key.BackReference = keys.First(k => k.k == key.k.BackReference).key;

		key.key.MemberName = key.key.AssociationType == AssociationType.OneToMany ?
			ToPlural(key.key.MemberName) : ToSingular(key.key.MemberName);
	}
}

string CheckType(Type type, string typeName)
{
	if (!Model.Usings.Contains(type.Namespace))
		Model.Usings.Add(type.Namespace);
	return typeName;
}

void LoadMetadata(DataConnection dataConnection)
{
	if (DataContextObject == null)
	{
		DataContextObject = new Class(DataContextName) { BaseClass = BaseDataContextClass };
		Model.Types.Add(DataContextObject);
	}

	LoadServerMetadata(dataConnection);

	if (Tables.Values.SelectMany(_ => _.ForeignKeys.Values).Any(_ => _.AssociationType == AssociationType.OneToMany))
		Model.Usings.Add("System.Collections.Generic");

	var keyWords = new HashSet<string>
	{
		"abstract", "as",       "base",     "bool",    "break",     "byte",     "case",       "catch",     "char",    "checked",
		"class",    "const",    "continue", "decimal", "default",   "delegate", "do",         "double",    "else",    "enum",
		"event",    "explicit", "extern",   "false",   "finally",   "fixed",    "float",      "for",       "foreach", "goto",
		"if",       "implicit", "in",       "int",     "interface", "internal", "is",         "lock",      "long",    "new",
		"null",     "object",   "operator", "out",     "override",  "params",   "private",    "protected", "public",  "readonly",
		"ref",      "return",   "sbyte",    "sealed",  "short",     "sizeof",   "stackalloc", "static",    "struct",  "switch",
		"this",     "throw",    "true",     "try",     "typeof",    "uint",     "ulong",      "unchecked", "unsafe",  "ushort",
		"using",    "virtual",  "volatile", "void",    "while"
	};

	foreach (var t in Tables.Values)
	{
		if (keyWords.Contains(t.TypeName))
			t.TypeName = "@" + t.TypeName;

		if (keyWords.Contains(t.DataContextPropertyName))
			t.DataContextPropertyName = "@" + t.DataContextPropertyName;

		foreach (var col in t.Columns.Values)
			if (keyWords.Contains(col.MemberName))
				col.MemberName = "@" + col.MemberName;
	}
}

void GenerateTypesFromMetadata()
{
	if (Tables.Count == 0)
		return;

	Model.Usings.Add("LinqToDB");
	Model.Usings.Add("LinqToDB.Mapping");

	if (NamespaceName == null)
		NamespaceName = "DataModel";

	var props = new MemberGroup { IsCompact = true };

	DataContextObject.Members.Insert(0, props);

	foreach (var t in Tables.Values.OrderBy(tbl => tbl.TypeName))
	{
		var dcProp = new Property(
			string.Format("Table<{0}>", t.TypeName),
			t.DataContextPropertyName,
			new[] { string.Format("this.GetTable<{0}>()", t.TypeName) },
			null);

		props.Members.Add(dcProp);

		var tableAttrs = new List<string>();

		if (DatabaseName != null) tableAttrs.Add("Database=" + '"' + DatabaseName + '"');
		if (t.Schema     != null) tableAttrs.Add("Schema="   + '"' + t.Schema     + '"');

		tableAttrs.Add((tableAttrs.Count == 0 ? "" : "Name=") + '"' + t.TableName + '"');

		t.Attributes.Add(new Attribute("Table", tableAttrs.ToArray()) { IsSeparated = true } );

		if (t.IsView)
			t.Comment.Add(" View");

		if (!string.IsNullOrWhiteSpace(t.Description))
		{
			t.     Comment.Add("/ <summary>");
			t.     Comment.Add("/ " + t.Description);
			t.     Comment.Add("/ </summary>");
			dcProp.Comment.Add("/ <summary>");
			dcProp.Comment.Add("/ " + t.Description);
			dcProp.Comment.Add("/ </summary>");
		}

		var columns     = new MemberGroup { IsCompact = true };
		var nPKs        = t.Columns.Values.Count(c => c.IsPrimaryKey);
		var allNullable = t.Columns.Values.All  (c => c.IsNullable || c.IsIdentity);

		foreach (var c in t.Columns.Values)
		{
			// Column.
			//
			var ca = new Attribute("Column");
			var canBeReplaced = true;

			if (c.MemberName != c.ColumnName)
			{
				ca.Parameters.Add('"' + c.ColumnName + '"');
				canBeReplaced = false;
			}

			if (c.SkipOnInsert && !c.IsIdentity)
			{
				ca.Parameters.Add("SkipOnInsert=true");
				canBeReplaced = false;
			}

			if (c.SkipOnUpdate && !c.IsIdentity)
			{
				ca.Parameters.Add("SkipOnUpdate=true");
				canBeReplaced = false;
			}

			c.Attributes.Add(ca);

			// PK.
			//
			if (c.IsPrimaryKey)
			{
				var pka = new Attribute("PrimaryKey");

				if (nPKs > 1)
					pka.Parameters.Add(c.PrimaryKeyOrder.ToString());

				if (canBeReplaced)
					c.Attributes[0] = pka;
				else
					c.Attributes.Add(pka);

				canBeReplaced = false;
			}

			// Identity.
			//
			if (c.IsIdentity)
			{
				var ida = new Attribute("Identity");

				if (canBeReplaced)
					c.Attributes[0] = ida;
				else
					c.Attributes.Add(ida);

				canBeReplaced = false;
			}

			// Nullable.
			//
			if (c.IsNullable)
				c.Attributes.Add(new Attribute((allNullable ? "" : "   ") + "Nullable"));
			else if (!c.IsIdentity)
				c.Attributes.Add(new Attribute("NotNull"));

			if (!string.IsNullOrWhiteSpace(c.Description))
			{
				c.Comment.Add("/ <summary>");
				c.Comment.Add("/ " + c.Description);
				c.Comment.Add("/ </summary>");
			}

			// End line comment.
			//
			c.EndLineComment = c.ColumnType;

			columns.Members.Add(c);
		}

		t.Members.Add(columns);

		if (t.ForeignKeys.Count > 0)
		{
			var associations = new MemberGroup { Region = "Associations" };

			foreach (var key in t.ForeignKeys.Values)
			{
				key.Comment.Add("/ <summary>");
				key.Comment.Add("/ " + key.KeyName);
				key.Comment.Add("/ </summary>");

				if (key.AssociationType == AssociationType.OneToMany)
					key.Type = string.Format(OneToManyAssociationType, key.OtherTable.TypeName);
				else
					key.Type = key.OtherTable.TypeName;

				var aa = new Attribute("Association");

				aa.Parameters.Add("ThisKey=\""   + string.Join(", ", (from c in key.ThisColumns  select c.MemberName).ToArray()) + "\"");
				aa.Parameters.Add("OtherKey=\""  + string.Join(", ", (from c in key.OtherColumns select c.MemberName).ToArray()) + "\"");
				aa.Parameters.Add("CanBeNull=" + (key.CanBeNull ? "true" : "false"));

				key.Attributes.Add(aa);

				associations.Members.Add(key);
			}

			t.Members.Add(associations);
		}

		Model.Types.Add(t);
	}

	Tables.Clear();
}

Dictionary<string,Table> Tables = new Dictionary<string,Table>();

public partial class Table : Class
{
	public string Schema                  { get; set; }
	public string TableName               { get; set; }
	public string DataContextPropertyName { get; set; }
	public bool   IsView                  { get; set; }
	public string Description             { get; set; }

	public string TypeName
	{
		get { return Name;  }
		set { Name = value; }
	}

	public Dictionary<string,Column>     Columns;
	public Dictionary<string,ForeignKey> ForeignKeys = new Dictionary<string,ForeignKey>();
}

public partial class Column : Property
{
	public string    ColumnName; // Column name in database
	public bool      IsNullable;
	public bool      IsIdentity;
	public string    ColumnType; // Type of the column in database
	public DbType    DbType;
	public string    Description;
	public bool      IsPrimaryKey;
	public int       PrimaryKeyOrder;
	public bool      SkipOnUpdate;
	public bool      SkipOnInsert;

	public string MemberName
	{
		get { return Name;  }
		set { Name = value; }
	}
}

public enum AssociationType
{
	Auto,
	OneToOne,
	OneToMany,
	ManyToOne,
}

public partial class ForeignKey : Property
{
	public string       KeyName;
	public Table        OtherTable;
	public List<Column> ThisColumns;
	public List<Column> OtherColumns;
	public bool         CanBeNull;
	public ForeignKey   BackReference;

	public string MemberName
	{
		get { return Name;  }
		set { Name = value; }
	}

	private AssociationType _associationType = AssociationType.Auto;
	public  AssociationType  AssociationType
	{
		get { return _associationType; }
		set
		{
			_associationType = value;

			if (BackReference != null)
			{
				switch (value)
				{
					case AssociationType.Auto      : BackReference.AssociationType = AssociationType.Auto;      break;
					case AssociationType.OneToOne  : BackReference.AssociationType = AssociationType.OneToOne;  break;
					case AssociationType.OneToMany : BackReference.AssociationType = AssociationType.ManyToOne; break;
					case AssociationType.ManyToOne : BackReference.AssociationType = AssociationType.OneToMany; break;
				}
			}
		}
	}
}
#>
