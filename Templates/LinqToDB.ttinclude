<#@ assembly name="System.Data"      #>
<#@ import namespace="System.Data"   #>
<#@ import namespace="LinqToDB.Data" #>
<#@ include file="T4Model.ttinclude" #>
<#
	{
		var beforeGenerateModel = BeforeGenerateModel;
		BeforeGenerateModel = () =>
		{
			GenerateTypesFromMetadata();
			beforeGenerateModel();
		};
	}
#><#+

string   NamespaceName
{
	get { return Model.Namespace.Name;  }
	set { Model.Namespace.Name = value; }
}

string   DatabaseName             = null;
string   DataContextName          = null;
string   BaseDataContextClass     = "LinqToDB.Data.DataConnection";
string   BaseEntityClass          = null;
string   OneToManyAssociationType = "IEnumerable<{0}>";

string   OwnerToInclude           = null;
string[] DatabaseQuote            = null;

bool     RenderField              = false;
bool     RenderBackReferences     = true;
bool     RenderForeignKeys        = true;

Class    DataContextObject;

bool PluralizeClassNames                 = false;
bool SingularizeClassNames               = true;
bool PluralizeDataContextPropertyNames   = true;
bool SingularizeDataContextPropertyNames = false;

void LoadServerMetadata(DataConnection dataConnection)
{
	var sp = dataConnection.DataProvider.GetSchemaProvider();
	var db = sp.GetSchema(dataConnection);

	if (DataContextName == null)
		DataContextObject.Name = DataContextName = db.Database + "DB";

	DataContextObject.Comment.Add("/ <summary>");
	DataContextObject.Comment.Add("/ Database       : " + db.Database);
	DataContextObject.Comment.Add("/ Data Source    : " + db.DataSource);
	DataContextObject.Comment.Add("/ Server Version : " + db.ServerVersion);
	DataContextObject.Comment.Add("/ </summary>");

	var tables = db.Tables
		.Select(t => new
		{
			t,
			key = t.IsDefaultSchema ? t.TableName : t.SchemaName + "." + t.TableName,
			table = new Table
			{
				Schema                  = t.IsDefaultSchema ? null : t.SchemaName,
				BaseClass               = BaseEntityClass,
				TableName               = t.TableName,
				TypeName                =
					PluralizeClassNames   ? ToPlural  (t.TypeName) :
					SingularizeClassNames ? ToSingular(t.TypeName) : t.TypeName,
				DataContextPropertyName =
					PluralizeDataContextPropertyNames   ? ToPlural  (t.TypeName) :
					SingularizeDataContextPropertyNames ? ToSingular(t.TypeName) : t.TypeName,
				IsView                  = t.IsView,
				Description             = t.Description,
				Columns                 = t.Columns.ToDictionary(
					c => c.ColumnName,
					c => new Column
					{
						ColumnName      = c.ColumnName,
						ColumnType      = c.ColumnType,
						IsNullable      = c.IsNullable,
						IsIdentity      = c.IsIdentity,
						IsPrimaryKey    = c.IsPrimaryKey,
						PrimaryKeyOrder = c.PrimaryKeyOrder,
						MemberName      = CheckType(c.SystemType, c.MemberName),
						Type            = c.MemberType,
						SkipOnInsert    = c.SkipOnInsert,
						SkipOnUpdate    = c.SkipOnUpdate,
						Description     = c.Description,
					})
			}
		})
		.ToList();

	foreach (var t in tables)
		Tables.Add(t.key, t.table);

	var keys =
	(
		from t in tables
		from k in t.t.ForeignKeys
		let otherTable = tables.Where(tbl => tbl.t == k.OtherTable).Select(tbl => tbl.table).Single()
		select new
		{
			k,
			k.KeyName,
			t,
			key = new ForeignKey
			{
				KeyName         = k.KeyName,
				OtherTable      = otherTable,
				OtherColumns    = k.OtherColumns.Select(c => otherTable.Columns[c.ColumnName]).ToList(),
				ThisColumns     = k.ThisColumns. Select(c => t.table.   Columns[c.ColumnName]).ToList(),
				CanBeNull       = k.CanBeNull,
				MemberName      = k.MemberName,
				AssociationType = (AssociationType)(int)k.AssociationType,
			}
		}
	).ToList();

	foreach (var key in keys)
	{
		key.t.table.ForeignKeys.Add(key.KeyName, key.key);

		if (key.k.BackReference != null)
			key.key.BackReference = keys.First(k => k.k == key.k.BackReference).key;

		key.key.MemberName = key.key.AssociationType == AssociationType.OneToMany ?
			ToPlural(key.key.MemberName) : ToSingular(key.key.MemberName);
	}

	var procedures = db.Procedures
		.Select(p => new
		{
			p,
			key = p.IsDefaultSchema ? p.ProcedureName : p.SchemaName + "." + p.ProcedureName,
			proc = new Procedure
			{
				Schema          = p.IsDefaultSchema ? null : p.SchemaName,
				ProcedureName   = p.ProcedureName,
				Name            = p.MemberName,
				IsFunction      = p.IsFunction,
				IsTableFunction = p.IsTableFunction,
				IsDefaultSchema = p.IsDefaultSchema,
				ResultTable     = p.ResultTable == null ? null :
					new Table
					{
						TypeName =
							PluralizeClassNames   ? ToPlural  (p.ResultTable.TypeName) :
							SingularizeClassNames ? ToSingular(p.ResultTable.TypeName) : p.ResultTable.TypeName,
						Columns  = p.ResultTable.Columns.ToDictionary(
							c => c.ColumnName,
							c => new Column
							{
								ColumnName      = c.ColumnName,
								ColumnType      = c.ColumnType,
								IsNullable      = c.IsNullable,
								IsIdentity      = c.IsIdentity,
								IsPrimaryKey    = c.IsPrimaryKey,
								PrimaryKeyOrder = c.PrimaryKeyOrder,
								MemberName      = CheckType(c.SystemType, c.MemberName),
								Type            = c.MemberType,
								SkipOnInsert    = c.SkipOnInsert,
								SkipOnUpdate    = c.SkipOnUpdate,
								Description     = c.Description,
							})
					},
				SimilarTables  = p.SimilarTables == null ? new List<Table>() :
					p.SimilarTables
						.Select(t => tables.Single(tbl => tbl.t == t).table)
						.ToList(),
				ProcParameters = p.Parameters
					.Select(pr => new Parameter
					{
						SchemaName    = pr.SchemaName,
						SchemaType    = pr.SchemaType,
						IsIn          = pr.IsIn,
						IsOut         = pr.IsOut,
						IsResult      = pr.IsResult,
						Size          = pr.Size,
						ParameterName = pr.ParameterName,
						ParameterType = pr.ParameterType,
						SystemType    = pr.SystemType,
						DataType      = pr.DataType.ToString(),
					})
					.ToList(),
			}
		})
		.ToList();

	foreach (var p in procedures)
		Procedures.Add(p.key, p.proc);
}

string CheckType(Type type, string typeName)
{
	if (!Model.Usings.Contains(type.Namespace))
		Model.Usings.Add(type.Namespace);
	return typeName;
}

void LoadMetadata(DataConnection dataConnection)
{
	if (DataContextObject == null)
	{
		DataContextObject = new Class(DataContextName)
		{
			BaseClass = BaseDataContextClass,
		};
		Model.Types.Add(DataContextObject);
	}

	LoadServerMetadata(dataConnection);

	if (Tables.Values.SelectMany(_ => _.ForeignKeys.Values).Any(_ => _.AssociationType == AssociationType.OneToMany))
		Model.Usings.Add("System.Collections.Generic");

	var keyWords = new HashSet<string>
	{
		"abstract", "as",       "base",     "bool",    "break",     "byte",     "case",       "catch",     "char",    "checked",
		"class",    "const",    "continue", "decimal", "default",   "delegate", "do",         "double",    "else",    "enum",
		"event",    "explicit", "extern",   "false",   "finally",   "fixed",    "float",      "for",       "foreach", "goto",
		"if",       "implicit", "in",       "int",     "interface", "internal", "is",         "lock",      "long",    "new",
		"null",     "object",   "operator", "out",     "override",  "params",   "private",    "protected", "public",  "readonly",
		"ref",      "return",   "sbyte",    "sealed",  "short",     "sizeof",   "stackalloc", "static",    "struct",  "switch",
		"this",     "throw",    "true",     "try",     "typeof",    "uint",     "ulong",      "unchecked", "unsafe",  "ushort",
		"using",    "virtual",  "volatile", "void",    "while"
	};

	foreach (var t in Tables.Values)
	{
		if (keyWords.Contains(t.TypeName))
			t.TypeName = "@" + t.TypeName;

		if (keyWords.Contains(t.DataContextPropertyName))
			t.DataContextPropertyName = "@" + t.DataContextPropertyName;

		foreach (var col in t.Columns.Values)
			if (keyWords.Contains(col.MemberName))
				col.MemberName = "@" + col.MemberName;
	}
}

Action AfterGenerateLinqToDBModel = () => {};

void GenerateTypesFromMetadata()
{
	if (Tables.Count == 0)
		return;

	Model.Usings.Add("LinqToDB");
	Model.Usings.Add("LinqToDB.Mapping");

	if (NamespaceName == null)
		NamespaceName = "DataModel";

	var props = new MemberGroup { IsCompact = true };

	DataContextObject.Members.Add(new Method(null, DataContextObject.Name));
	DataContextObject.Members.Add(new Method(null, DataContextObject.Name, new[] { "string configuration" }) { AfterSignature = { ": base(configuration)" } });

	DataContextObject.Members.Insert(0, props);

	foreach (var t in Tables.Values.OrderBy(tbl => tbl.TypeName))
	{
		var dcProp = new Property(
			string.Format("Table<{0}>", t.TypeName),
			t.DataContextPropertyName,
			new[] { string.Format("this.GetTable<{0}>()", t.TypeName) },
			null);

		props.Members.Add(dcProp);

		var tableAttrs = new List<string>();

		if (DatabaseName != null) tableAttrs.Add("Database=" + '"' + DatabaseName + '"');
		if (t.Schema     != null) tableAttrs.Add("Schema="   + '"' + t.Schema     + '"');

		tableAttrs.Add((tableAttrs.Count == 0 ? "" : "Name=") + '"' + t.TableName + '"');

		t.Attributes.Add(new Attribute("Table", tableAttrs.ToArray()) { IsSeparated = true } );

		if (t.IsView)
			t.Comment.Add(" View");

		if (!string.IsNullOrWhiteSpace(t.Description))
		{
			t.     Comment.Add("/ <summary>");
			t.     Comment.Add("/ " + t.Description);
			t.     Comment.Add("/ </summary>");
			dcProp.Comment.Add("/ <summary>");
			dcProp.Comment.Add("/ " + t.Description);
			dcProp.Comment.Add("/ </summary>");
		}

		var columns     = new MemberGroup { IsCompact = true };
		var nPKs        = t.Columns.Values.Count(c => c.IsPrimaryKey);
		var allNullable = t.Columns.Values.All  (c => c.IsNullable || c.IsIdentity);

		foreach (var c in t.Columns.Values)
		{
			// Column.
			//
			var ca = new Attribute("Column");
			var canBeReplaced = true;

			if (c.MemberName != c.ColumnName)
			{
				ca.Parameters.Add('"' + c.ColumnName + '"');
				canBeReplaced = false;
			}

			if (c.SkipOnInsert && !c.IsIdentity)
			{
				ca.Parameters.Add("SkipOnInsert=true");
				canBeReplaced = false;
			}

			if (c.SkipOnUpdate && !c.IsIdentity)
			{
				ca.Parameters.Add("SkipOnUpdate=true");
				canBeReplaced = false;
			}

			c.Attributes.Add(ca);

			// PK.
			//
			if (c.IsPrimaryKey)
			{
				var pka = new Attribute("PrimaryKey");

				if (nPKs > 1)
					pka.Parameters.Add(c.PrimaryKeyOrder.ToString());

				if (canBeReplaced)
					c.Attributes[0] = pka;
				else
					c.Attributes.Add(pka);

				canBeReplaced = false;
			}

			// Identity.
			//
			if (c.IsIdentity)
			{
				var ida = new Attribute("Identity");

				if (canBeReplaced)
					c.Attributes[0] = ida;
				else
					c.Attributes.Add(ida);

				canBeReplaced = false;
			}

			// Nullable.
			//
			if (c.IsNullable)
				c.Attributes.Add(new Attribute((allNullable ? "" : "   ") + "Nullable"));
			else if (!c.IsIdentity)
				c.Attributes.Add(new Attribute("NotNull"));

			if (!string.IsNullOrWhiteSpace(c.Description))
			{
				c.Comment.Add("/ <summary>");
				c.Comment.Add("/ " + c.Description);
				c.Comment.Add("/ </summary>");
			}

			// End line comment.
			//
			c.EndLineComment = c.ColumnType;

			columns.Members.Add(c);
		}

		t.Members.Add(columns);

		if (t.ForeignKeys.Count > 0)
		{
			var associations = new MemberGroup { Region = "Associations" };

			foreach (var key in t.ForeignKeys.Values)
			{
				key.Comment.Add("/ <summary>");
				key.Comment.Add("/ " + key.KeyName);
				key.Comment.Add("/ </summary>");

				if (key.AssociationType == AssociationType.OneToMany)
					key.Type = string.Format(OneToManyAssociationType, key.OtherTable.TypeName);
				else
					key.Type = key.OtherTable.TypeName;

				var aa = new Attribute("Association");

				aa.Parameters.Add("ThisKey=\""   + string.Join(", ", (from c in key.ThisColumns  select c.MemberName).ToArray()) + "\"");
				aa.Parameters.Add("OtherKey=\""  + string.Join(", ", (from c in key.OtherColumns select c.MemberName).ToArray()) + "\"");
				aa.Parameters.Add("CanBeNull=" + (key.CanBeNull ? "true" : "false"));

				key.Attributes.Add(aa);

				associations.Members.Add(key);
			}

			t.Members.Add(associations);
		}

		Model.Types.Add(t);
	}

	if (Procedures.Count > 0)
	{
		Model.Usings.Add("System.Collections.Generic");
		Model.Usings.Add("System.Data");
		Model.Usings.Add("LinqToDB.Data");
		Model.Usings.Add("LinqToDB.Common");

		var procs = new MemberGroup { Region = "Stored Procedures" };
		var tabfs = new MemberGroup { Region = "Table Functions" };
		var funcs = new MemberGroup { Region = "SQL Functions" };

		foreach (var p in Procedures.Values)
		{
			var proc = new MemberGroup { Region = p.Name };

			if (p.IsTableFunction)
			{
				p.Attributes.Add(new Attribute("Sql.TableFunction", "Name=\"" + p.ProcedureName + "\""));
				p.Type = "Table<" + p.ResultTable.TypeName + ">";
			}
			else if (p.IsFunction)
			{
				p.IsStatic = true;
				p.Type = p.ProcParameters.Single(pr => pr.IsResult).ParameterType;
				p.Attributes.Add(new Attribute("Sql.Function", "Name=\"" + p.ProcedureName + "\"", "ServerSideOnly=true"));
			}
			else
			{
				p.IsStatic = true;
				p.Type     = p.ResultTable == null ? "int" : "IEnumerable<" + p.ResultTable.TypeName + ">";
				p.Parameters.Add("this DataConnection dataConnection");
			}

			foreach (var pr in p.ProcParameters.Where(par => !par.IsResult))
				p.Parameters.Add(string.Format("{0}{1} {2}",
					pr.IsOut ? pr.IsIn ? "ref " : "out " : "", pr.ParameterType, pr.ParameterName));

			if (p.IsTableFunction)
			{
				var body = string.Format("return GetTable<{0}>(this, (MethodInfo)MethodBase.GetCurrentMethod()", p.ResultTable.TypeName);

				body += p.ProcParameters.Count == 0 ? ");" : ",";

				p.Body.Add(body);

				for (var i = 0; i < p.ProcParameters.Count; i++)
					p.Body.Add("\t" + p.ProcParameters[i].ParameterName + (i + 1 == p.ProcParameters.Count ? ");" : ","));
			}
			else if (p.IsFunction)
			{
				p.Body.Add("throw new InvalidOperationException();");
			}
			else
			{
				var spName = "\"";

				if (DatabaseName != null) spName += "[" + DatabaseName + "].";
				if (p.Schema     != null) spName += "[" + p.Schema     + "].";
				else if (DatabaseName != null) spName += ".";

				spName += "[" + p.ProcedureName + "]\"";
				spName += p.ProcParameters.Count == 0 ? ");" : ",";

				var hasOut = p.ProcParameters.Any(pr => pr.IsOut);
				var prefix = hasOut ? "var ret = " : "return ";

				if (p.ResultTable == null)
					p.Body.Add(prefix + "dataConnection.ExecuteProc(" + spName);
				else
					p.Body.Add(prefix + "dataConnection.QueryProc<" + p.ResultTable.TypeName + ">(" + spName);

				var maxLenSchema = p.ProcParameters.Max(pr => (int?)pr.SchemaName.   Length) ?? 0;
				var maxLenParam  = p.ProcParameters.Max(pr => (int?)pr.ParameterName.Length) ?? 0;
				var maxLenType   = p.ProcParameters.Max(pr => (int?)pr.ParameterType.Length) ?? 0;

				for (var i = 0; i < p.ProcParameters.Count; i++)
				{
					var pr = p.ProcParameters[i];

					var str = string.Format("\tnew DataParameter(\"{0}\", {1}{2})",
						pr.SchemaName,
						LenDiff(maxLenSchema, pr.SchemaName),
						pr.ParameterName);

					if (pr.IsOut)
					{
						str += LenDiff(maxLenParam, pr.ParameterName);
						str += " { Direction = " + (pr.IsIn ? "ParameterDirection.InputOutput" : "ParameterDirection.Output");

						if (pr.Size != null)
							str += ", Size = " + pr.Size.Value;

						str += " }";
					}

					str += i + 1 == p.ProcParameters.Count ? ");" : ",";

					p.Body.Add(str);
				}

				if (hasOut)
				{
					p.Body.Add("");

					foreach (var pr in p.ProcParameters.Where(_ => _.IsOut))
					{
						var str = string.Format("{0} {1}= Converter.ChangeTypeTo<{2}>{3}(((IDbDataParameter)dataConnection.Command.Parameters[\"{4}\"]).{5}Value);",
							pr.ParameterName,
							LenDiff(maxLenParam,  pr.ParameterName),
							pr.ParameterType,
							LenDiff(maxLenType,   pr.ParameterType),
							pr.SchemaName,
							LenDiff(maxLenSchema, pr.SchemaName));

						p.Body.Add(str);
					}

					p.Body.Add("");
					p.Body.Add("return ret;");
				}
			}

			if (p.ResultTable != null && p.ResultTable.DataContextPropertyName == null)
			{
				var columns = new MemberGroup { IsCompact = true };

				foreach (var c in p.ResultTable.Columns.Values)
				{
					if (c.MemberName != c.ColumnName)
						c.Attributes.Add(new Attribute("Column") { Parameters = { '"' + c.ColumnName + '"' } });
					columns.Members.Add(c);
				}

				p.ResultTable.Members.Add(columns);
				proc.Members.Add(p.ResultTable);
			}

			proc.Members.Add(p);

			     if (!p.IsFunction)     procs.Members.Add(proc);
			else if (p.IsTableFunction) tabfs.Members.Add(proc);
			else                        funcs.Members.Add(proc);
		}

		if (procs.Members.Count > 0)
			Model.Types.Add(new Class(DataContextObject.Name + "Extensions", procs) { IsStatic = true });

		if (funcs.Members.Count > 0)
			Model.Types.Add(new Class("SqlFunctions", funcs) { IsStatic = true });

		if (tabfs.Members.Count > 0) DataContextObject.Members.Add(tabfs);
	}

	Tables.    Clear();
	Procedures.Clear();

	AfterGenerateLinqToDBModel();
}

Dictionary<string,Table>     Tables     = new Dictionary<string,Table>    ();
Dictionary<string,Procedure> Procedures = new Dictionary<string,Procedure>();

public partial class Table : Class
{
	public string Schema                  { get; set; }
	public string TableName               { get; set; }
	public string DataContextPropertyName { get; set; }
	public bool   IsView                  { get; set; }
	public string Description             { get; set; }

	public string TypeName
	{
		get { return Name;  }
		set { Name = value; }
	}

	public Dictionary<string,Column>     Columns;
	public Dictionary<string,ForeignKey> ForeignKeys = new Dictionary<string,ForeignKey>();
}

public partial class Column : Property
{
	public string    ColumnName; // Column name in database
	public bool      IsNullable;
	public bool      IsIdentity;
	public string    ColumnType; // Type of the column in database
	public DbType    DbType;
	public string    Description;
	public bool      IsPrimaryKey;
	public int       PrimaryKeyOrder;
	public bool      SkipOnUpdate;
	public bool      SkipOnInsert;

	public string MemberName
	{
		get { return Name;  }
		set { Name = value; }
	}
}

public enum AssociationType
{
	Auto,
	OneToOne,
	OneToMany,
	ManyToOne,
}

public partial class ForeignKey : Property
{
	public string       KeyName;
	public Table        OtherTable;
	public List<Column> ThisColumns;
	public List<Column> OtherColumns;
	public bool         CanBeNull;
	public ForeignKey   BackReference;

	public string MemberName
	{
		get { return Name;  }
		set { Name = value; }
	}

	private AssociationType _associationType = AssociationType.Auto;
	public  AssociationType  AssociationType
	{
		get { return _associationType; }
		set
		{
			_associationType = value;

			if (BackReference != null)
			{
				switch (value)
				{
					case AssociationType.Auto      : BackReference.AssociationType = AssociationType.Auto;      break;
					case AssociationType.OneToOne  : BackReference.AssociationType = AssociationType.OneToOne;  break;
					case AssociationType.OneToMany : BackReference.AssociationType = AssociationType.ManyToOne; break;
					case AssociationType.ManyToOne : BackReference.AssociationType = AssociationType.OneToMany; break;
				}
			}
		}
	}
}

public partial class Procedure : Method
{
	public string Schema          { get; set; }
	public string ProcedureName   { get; set; }
	public bool   IsFunction      { get; set; }
	public bool   IsTableFunction { get; set; }
	public bool   IsDefaultSchema { get; set; }

	public Table           ResultTable    { get; set; }
	public List<Table>     SimilarTables  { get; set; }
	public List<Parameter> ProcParameters { get; set; }
}

public class Parameter
{
	public string   SchemaName    { get; set; }
	public string   SchemaType    { get; set; }
	public bool     IsIn          { get; set; }
	public bool     IsOut         { get; set; }
	public bool     IsResult      { get; set; }
	public int?     Size          { get; set; }

	public string   ParameterName { get; set; }
	public string   ParameterType { get; set; }
	public Type     SystemType    { get; set; }
	public string   DataType      { get; set; }
}

#>
