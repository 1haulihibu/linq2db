<#@ assembly name="System.Data"      #>
<#@ import namespace="System.Data"   #>
<#@ include file="T4Model.ttinclude" #>
<#
	{
		var beforeGenerateModel = BeforeGenerateModel;
		BeforeGenerateModel = () =>
		{
			GenerateTypesFromMetadata();
			beforeGenerateModel();
		};
	}
#><#+

string   NamespaceName
{
	get { return Model.Namespace.Name;  }
	set { Model.Namespace.Name = value; }
}

string   DatabaseName             = null;
string   DataContextName          = "DataContext";
string   BaseDataContextClass     = "LinqToDB.Data.DataConnection";
string   BaseEntityClass          = null;
string   OneToManyAssociationType = "IEnumerable<{0}>";

string   OwnerToInclude           = null;
string[] DatabaseQuote            = null;

bool     RenderField              = false;
bool     RenderBackReferences     = true;
bool     RenderForeignKeys        = true;

Class    DataContextObject;

void LoadMetadata(IDbConnection conn)
{
	if (conn.State == ConnectionState.Closed)
		conn.Open();

	if (DataContextObject == null)
	{
		DataContextObject = new Class(DataContextName) { BaseClass = BaseDataContextClass };
		Model.Types.Add(DataContextObject);
	}

	LoadServerMetadata(conn);

	foreach (var t in Tables.Values)
	{
		t.BaseClass = BaseEntityClass;

		if (t.TypeName.Contains(" "))
		{
			var ss = t.TypeName.Split(' ').Where(_ => _.Trim().Length > 0).Select(_ => char.ToUpper(_[0]) + _.Substring(1));
			t.TypeName = string.Join("", ss.ToArray());
		}

		foreach (var key in t.ForeignKeys.Values.ToList())
			if (!key.KeyName.EndsWith("_BackReference"))
				key.OtherTable.ForeignKeys.Add(key.KeyName + "_BackReference", key.BackReference = new ForeignKey
				{
					KeyName         = key.KeyName    + "_BackReference",
					MemberName      = key.MemberName + "_BackReference",
					AssociationType = AssociationType.Auto,
					OtherTable      = t,
					ThisColumns     = key.OtherColumns,
					OtherColumns    = key.ThisColumns,
				});

		foreach (var key in t.ForeignKeys.Values)
		{
			if (key.BackReference != null && key.AssociationType == AssociationType.Auto)
			{
				if (key.ThisColumns.All(_ => _.IsPrimaryKey))
				{
					if (t.Columns.Values.Count(_ => _.IsPrimaryKey) == key.ThisColumns.Count)
						key.AssociationType = AssociationType.OneToOne;
					else
						key.AssociationType = AssociationType.ManyToOne;
				}
				else
					key.AssociationType = AssociationType.ManyToOne;

				key.CanBeNull = key.ThisColumns.All(_ => _.IsNullable);
			}
		}

		foreach (var key in t.ForeignKeys.Values)
		{
			var name = key.MemberName;

			if (key.BackReference != null && key.ThisColumns.Count == 1 && key.ThisColumns[0].MemberName.ToLower().EndsWith("id"))
			{
				name = key.ThisColumns[0].MemberName;
				name = name.Substring(0, name.Length - "id".Length);

				if (!t.ForeignKeys.Values.Select(_ => _.MemberName).Concat(
						t.Columns.    Values.Select(_ => _.MemberName)).Concat(
						new[] { t.TypeName }).Any(_ => _ == name))
				{
					name = key.MemberName;;
				}
			}
			
			if (name == key.MemberName)
			{
				if (name.StartsWith("FK_"))
					name = name.Substring(3);

				if (name.EndsWith("_BackReference"))
					name = name.Substring(0, name.Length - "_BackReference".Length);

				name = string.Join("", name.Split('_').Where(_ => _.Length > 0 && _ != t.TableName).ToArray());

//				if (name.Length > 0)
//					name = key.AssociationType == AssociationType.OneToMany ? PluralizeAssociationName(name) : SingularizeAssociationName(name);
			}

			if (name.Length != 0 &&
				!t.ForeignKeys.Values.Select(_ => _.MemberName).Concat(
					t.Columns.    Values.Select(_ => _.MemberName)).Concat(
					new[] { t.TypeName }).Any(_ => _ == name))
			{
				key.MemberName = name;
			}
		}
	}

	if (Tables.Values.SelectMany(_ => _.ForeignKeys.Values).Any(_ => _.AssociationType == AssociationType.OneToMany))
		Model.Usings.Add("System.Collections.Generic");

	var keyWords = new HashSet<string>
	{
		"abstract", "as",       "base",     "bool",    "break",     "byte",     "case",       "catch",     "char",    "checked",
		"class",    "const",    "continue", "decimal", "default",   "delegate", "do",         "double",    "else",    "enum",
		"event",    "explicit", "extern",   "false",   "finally",   "fixed",    "float",      "for",       "foreach", "goto",
		"if",       "implicit", "in",       "int",     "interface", "internal", "is",         "lock",      "long",    "new",
		"null",     "object",   "operator", "out",     "override",  "params",   "private",    "protected", "public",  "readonly",
		"ref",      "return",   "sbyte",    "sealed",  "short",     "sizeof",   "stackalloc", "static",    "struct",  "switch",
		"this",     "throw",    "true",     "try",     "typeof",    "uint",     "ulong",      "unchecked", "unsafe",  "ushort",
		"using",    "virtual",  "volatile", "void",    "while"
	};

	foreach (var t in Tables.Values)
	{
		if (keyWords.Contains(t.TypeName))
			t.TypeName = "@" + t.TypeName;

		if (keyWords.Contains(t.DataContextPropertyName))
			t.DataContextPropertyName = "@" + t.DataContextPropertyName;

		foreach (var col in t.Columns.Values)
			if (keyWords.Contains(col.MemberName))
				col.MemberName = "@" + col.MemberName;
	}
}

void GenerateTypesFromMetadata()
{
	if (Tables.Count == 0)
		return;

	Model.Usings.Add("LinqToDB.Mapping");

	if (NamespaceName == null)
		NamespaceName = "DataModel";

	var props = new MemberGroup { IsCompact = true };

	DataContextObject.Members.Insert(0, props);

	foreach (var t in Tables.Values.OrderBy(tbl => tbl.TypeName))
	{
		var dcProp = new Property(
			string.Format("Table<{0}>", t.TypeName),
			(t.DataContextPropertyName ?? t.TypeName).ToString(),
			new[] { string.Format("this.GetTable<{0}>()", t.TypeName) },
			null);

		props.Members.Add(dcProp);

		var tableAttrs = new List<string>();

		if (DatabaseName != null) tableAttrs.Add("Database=" + '"' + DatabaseName + '"');
		if (t.Schema     != null) tableAttrs.Add("Schema="   + '"' + t.Schema     + '"');

		tableAttrs.Add((tableAttrs.Count == 0 ? "" : "Name=") + '"' + t.TableName + '"');

		t.Attributes.Add(new Attribute("Table", tableAttrs.ToArray()) { IsSeparated = true } );

		if (t.IsView)
			t.Comment.Add(" View");

		if (!string.IsNullOrWhiteSpace(t.Description))
		{
			t.     Comment.Add("/ <summary>");
			t.     Comment.Add("/ " + t.Description);
			t.     Comment.Add("/ </summary>");
			dcProp.Comment.Add("/ <summary>");
			dcProp.Comment.Add("/ " + t.Description);
			dcProp.Comment.Add("/ </summary>");
		}

		var columns     = new MemberGroup { IsCompact = true };
		var nPKs        = t.Columns.Values.Count(c => c.IsPrimaryKey);
		var allNullable = t.Columns.Values.All  (c => c.IsNullable || c.IsIdentity);

		foreach (var c in t.Columns.Values)
		{
			// Column.
			//
			var ca = new Attribute("Column");
			var canBeReplaced = true;

			if (c.MemberName != c.ColumnName)
			{
				ca.Parameters.Add('"' + c.ColumnName + '"');
				canBeReplaced = false;
			}

			if (c.SkipOnInsert)
			{
				ca.Parameters.Add("SkipOnInsert=true");
				canBeReplaced = false;
			}

			if (c.SkipOnUpdate)
			{
				ca.Parameters.Add("SkipOnUpdate=true");
				canBeReplaced = false;
			}

			c.Attributes.Add(ca);

			// PK.
			//
			if (c.IsPrimaryKey)
			{
				var pka = new Attribute("PrimaryKey");

				if (nPKs > 1)
					pka.Parameters.Add(c.PKOrder.ToString());

				if (canBeReplaced)
					c.Attributes[0] = pka;
				else
					c.Attributes.Add(pka);

				canBeReplaced = false;
			}

			// Identity.
			//
			if (c.IsIdentity)
			{
				var ida = new Attribute("Identity");

				if (canBeReplaced)
					c.Attributes[0] = ida;
				else
					c.Attributes.Add(ida);

				canBeReplaced = false;
			}

			// Nullable.
			//
			if (c.IsNullable)
				c.Attributes.Add(new Attribute((allNullable ? "" : "   ") + "Nullable"));
			else if (!c.IsIdentity)
				c.Attributes.Add(new Attribute("NotNull"));

			if (!string.IsNullOrWhiteSpace(c.Description))
			{
				c.Comment.Add("/ <summary>");
				c.Comment.Add("/ " + c.Description);
				c.Comment.Add("/ </summary>");
			}

			// End line comment.
			//
			var elComm = c.ColumnType;

			if (c.Length != 0)    elComm += "(" + c.Length + ")";
			if (c.Precision != 0) elComm += "(" + c.Precision + ","+ c.Scale + ")";

			c.EndLineComment = elComm;

			columns.Members.Add(c);
		}

		t.Members.Add(columns);

		if (t.ForeignKeys.Count > 0)
		{
			var associations = new MemberGroup { Region = "Associations" };

			foreach (var key in t.ForeignKeys.Values)
			{
				key.Comment.Add("/ <summary>");
				key.Comment.Add("/ " + key.KeyName);
				key.Comment.Add("/ </summary>");

				if (key.AssociationType == AssociationType.OneToMany)
					key.Type = string.Format(OneToManyAssociationType, key.OtherTable.TypeName);
				else
					key.Type = key.OtherTable.TypeName;

				var aa = new Attribute("Association");

				aa.Parameters.Add("ThisKey=\""   + string.Join(", ", (from c in key.ThisColumns  select c.MemberName).ToArray()) + "\"");
				aa.Parameters.Add("OtherKey=\""  + string.Join(", ", (from c in key.OtherColumns select c.MemberName).ToArray()) + "\"");
				aa.Parameters.Add("CanBeNull=" + (key.CanBeNull ? "true" : "false"));

				key.Attributes.Add(aa);

				associations.Members.Add(key);
			}

			t.Members.Add(associations);
		}

		Model.Types.Add(t);
	}

	Tables.Clear();
}

Dictionary<string,Table> Tables = new Dictionary<string,Table>();

public partial class Table : Class
{
	public string Schema                  { get; set; }
	public string TableName               { get; set; }
	public string DataContextPropertyName { get; set; }
	public bool   IsView                  { get; set; }
	public string Description             { get; set; }

	public string TypeName
	{
		get { return Name;  }
		set { Name = value; }
	}

	public Dictionary<string,Column>     Columns     = new Dictionary<string,Column>();
	public Dictionary<string,ForeignKey> ForeignKeys = new Dictionary<string,ForeignKey>();
}

public partial class Column : Property
{
	public int       ID;
	public string    ColumnName; // Column name in database
	public bool      IsNullable;
	public bool      IsIdentity;
	public string    ColumnType; // Type of the column in database
	public bool      IsClass;
	public DbType    DbType;
	public SqlDbType SqlDbType;
	public long      Length;
	public int       Precision;
	public int       Scale;
	public string    Description;
	public int       PKOrder = -1;
	public bool      SkipOnUpdate;
	public bool      SkipOnInsert;

	public bool IsPrimaryKey { get { return PKOrder >= 0; } }

	public string MemberName
	{
		get { return Name;  }
		set { Name = value; }
	}
}

public enum AssociationType
{
	Auto,
	OneToOne,
	OneToMany,
	ManyToOne,
}

public partial class ForeignKey : Property
{
	public string       KeyName;
	public Table        OtherTable;
	public List<Column> ThisColumns  = new List<Column>();
	public List<Column> OtherColumns = new List<Column>();
	public bool         CanBeNull    = true;
	public ForeignKey   BackReference;

	public string MemberName
	{
		get { return Name;  }
		set { Name = value; }
	}

	private AssociationType _associationType = AssociationType.Auto;
	public  AssociationType  AssociationType
	{
		get { return _associationType; }
		set
		{
			_associationType = value;

			if (BackReference != null)
			{
				switch (value)
				{
					case AssociationType.Auto      : BackReference.AssociationType = AssociationType.Auto;      break;
					case AssociationType.OneToOne  : BackReference.AssociationType = AssociationType.OneToOne;  break;
					case AssociationType.OneToMany : BackReference.AssociationType = AssociationType.ManyToOne; break;
					case AssociationType.ManyToOne : BackReference.AssociationType = AssociationType.OneToMany; break;
				}
			}
		}
	}
}
#>
