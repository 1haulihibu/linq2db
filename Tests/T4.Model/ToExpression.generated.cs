
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by ToExpression.tt template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System;
using System.Reflection;
using System.Linq.Expressions;

namespace Tests.T4.Model
{
	static class GeneratedExpressions
	{
		public static Expression<Action<int,int>> NoReturn()
		{
			var p0 = Expression.Parameter(typeof(int), "x");
			var p1 = Expression.Parameter(typeof(int), "y");

			return Expression.Lambda<Action<int,int>>(
				Expression.Call(
					Expression.Add(
						p0,
						p1),
					"ToString",
					new Type[0],
					new Expression[]
					{
						Expression.Constant("X", typeof(string))
					}),
				new ParameterExpression[]
				{
					p0,
					p1
				});
		}

		public static Expression<Func<int,int,int>> Multiply()
		{
			var p0 = Expression.Parameter(typeof(int), "x");
			var p1 = Expression.Parameter(typeof(int), "y");

			return Expression.Lambda<Func<int,int,int>>(
				Expression.Condition(
					Expression.GreaterThan(
						Expression.Negate(
							p0),
						Expression.Constant(0, typeof(int))),
					Expression.Add(
						p0,
						p1),
					Expression.Divide(
						p0,
						p1)),
				new ParameterExpression[]
				{
					p0,
					p1
				});
		}

		public static Expression<Func<DateTime,string,int>> Multiply1()
		{
			var p0 = Expression.Parameter(typeof(DateTime), "x");
			var p1 = Expression.Parameter(typeof(string), "y");

			return Expression.Lambda<Func<DateTime,string,int>>(
				Expression.Add(
					Expression.Negate(
						Expression.PropertyOrField(
							p0,
							"Day")),
					Expression.Convert(
						Expression.Call(
							p1,
							"get_Chars",
							new Type[0],
							new Expression[]
							{
								Expression.Constant(2, typeof(int))
							}),
						typeof(int))),
				new ParameterExpression[]
				{
					p0,
					p1
				});
		}

		public static Expression<Func<int,int,int,DateTime>> Multiply2()
		{
			var p0 = Expression.Parameter(typeof(int), "x");
			var p1 = Expression.Parameter(typeof(int), "y");
			var p2 = Expression.Parameter(typeof(int), "z");

			return Expression.Lambda<Func<int,int,int,DateTime>>(
				Expression.New(
#if NETCOREAPP1_0 || NETCOREAPP1_1 || NETCOREAPP2_0 || NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2 || NETSTANDARD1_3 || NETSTANDARD1_4 || NETSTANDARD1_5 || NETSTANDARD1_6 || NETSTANDARD1_6
					typeof(DateTime).GetTypeInfo().GetConstructor(new Type[] { typeof(int), typeof(int), typeof(int) }),
#else
					typeof(DateTime).GetConstructor(new Type[] { typeof(int), typeof(int), typeof(int) }),
#endif
					new Expression[]
					{
						Expression.Constant(1999, typeof(int)),
						p1,
						p2
					}),
				new ParameterExpression[]
				{
					p0,
					p1,
					p2
				});
		}

		public static Expression<Func<DateTime>> Multiply3()
		{
			return Expression.Lambda<Func<DateTime>>(
				Expression.New(typeof(DateTime)));
		}

		public static Expression<Func<int[]>> Method1()
		{
			return Expression.Lambda<Func<int[]>>(
				Expression.NewArrayInit(
					typeof(int),
					new Expression[]
					{
						Expression.Constant(2, typeof(int)),
						Expression.Constant(3, typeof(int)),
						Expression.Constant(4, typeof(int))
					}));
		}

		public static Expression<Func<int[]>> Method2()
		{
			return Expression.Lambda<Func<int[]>>(
				Expression.NewArrayBounds(
					typeof(int),
					new Expression[]
					{
						Expression.Constant(0, typeof(int))
					}));
		}

		public static Expression<Func<int[]>> Method3()
		{
			return Expression.Lambda<Func<int[]>>(
				Expression.NewArrayBounds(
					typeof(int),
					new Expression[]
					{
						Expression.Constant(2, typeof(int))
					}));
		}

		public static Expression<Func<int,int[]>> Method4()
		{
			var p0 = Expression.Parameter(typeof(int), "x");

			return Expression.Lambda<Func<int,int[]>>(
				Expression.NewArrayInit(
					typeof(int),
					new Expression[]
					{
						Expression.Constant(2147483647, typeof(int)),
						p0
					}),
				new ParameterExpression[]
				{
					p0
				});
		}

	}
}

