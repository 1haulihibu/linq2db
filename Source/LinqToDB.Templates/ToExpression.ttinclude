<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq.Expressions" #>
<#@ import namespace="System.Reflection" #>
<#+
LambdaExpression    _lambda;
Func<string,string> _replaceTypeFunc;

void ToExpression(string methodName, LambdaExpression expr, Func<string,string> replaceTypeFunc = null)
{
	_lambda          = expr;
	_replaceTypeFunc = replaceTypeFunc ?? (s => s);

	var returnType = TypeToString(expr.Type, false);

#>
		public static Expression<<#= returnType #>> <#= methodName #>
		{
<#+
	for (var i = 0; i < expr.Parameters.Count; i++)
	{
		var p = expr.Parameters[i];
#>
			var p<#= i #> = Expression.Parameter(<#= TypeToString(p.Type) #>, "<#= p.Name #>");
<#+
	}

	if (expr.Parameters.Count > 0)
	{
		GenerationEnvironment.AppendLine();
	}
#>
			return Expression.Lambda<<#= returnType #>>(<#+
	GenerateExpr(expr.Body);

	if (expr.Parameters.Count > 0)
	{
		#>,
				<#+
		GenerateExprs(expr.Parameters, "ParameterExpression");
	}
#>);
		}

<#+
}

string TypeToString(Type type, bool asTypeOf = true)
{
	var s = type.ToString()
		.Replace("System.Object", "object")
		.Replace("System.Int32",  "int")
		.Replace("System.String", "string")
		.Replace("System.", "")
		;

	if (s.Contains("`") && s.EndsWith("]"))
		s = (s + '`')
			.Replace("]`", ">")
			.Replace("`1[", "<")
			.Replace("`2[", "<")
			.Replace("`3[", "<")
			.Replace("`4[", "<")
			.Replace("`5[", "<")
			;

	return _replaceTypeFunc(asTypeOf ? $"typeof({s})" : s);
}

string ValueToString(object value)
{
	if (value == null)
		return "null";

	if (value is string)
		return '"' + value.ToString() + '"';

	if (value is Enum)
		return value.GetType().FullName + "." + value;

	return value.ToString();
}

void GenerateExprs(IEnumerable<Expression> exprs, string typeName = "Expression")
{
	var list = exprs.ToList();

	if (list.Count == 0)
	{
				#>new <#= typeName #>[0]<#+
	}
	else
	{
				#>new <#= typeName #>[]
				{<#+

		PushIndent("\t");

		for (var i = 0; i < list.Count; i++)
		{
			GenerateExpr(list[i]);

			if (i < list.Count - 1)
			{
				#>,<#+
			}
		}

		PopIndent();
#>

				}<#+
	}
}

void GenerateExpr(Expression expr)
{
	if (expr == null)
	{
		#>

				null<#+
		return;
	}

	var methodName = expr.NodeType.ToString();

	switch (expr.NodeType)
	{
		case ExpressionType.Conditional:
			methodName = "Condition";
			break;

		case ExpressionType.MemberAccess:
			{
				var e = (MemberExpression)expr;

				if (e.Expression == null)
				{
					methodName = e.Member is PropertyInfo? "Property" : "Field";
				}
				else
				{
					methodName = "PropertyOrField";
				}

				break;
			}

		case ExpressionType.Parameter:
			{
				#>

				p<#= _lambda.Parameters.IndexOf((ParameterExpression)expr) #><#+
				return;
			}
	}

#>

				Expression.<#= methodName #>(<#+

	switch (expr.NodeType)
	{
		case ExpressionType.Add:
		case ExpressionType.AddChecked:
		case ExpressionType.And:
		case ExpressionType.AndAlso:
		case ExpressionType.ArrayIndex:
		case ExpressionType.Assign:
		case ExpressionType.Coalesce:
		case ExpressionType.Divide:
		case ExpressionType.Equal:
		case ExpressionType.ExclusiveOr:
		case ExpressionType.GreaterThan:
		case ExpressionType.GreaterThanOrEqual:
		case ExpressionType.LeftShift:
		case ExpressionType.LessThan:
		case ExpressionType.LessThanOrEqual:
		case ExpressionType.Modulo:
		case ExpressionType.Multiply:
		case ExpressionType.MultiplyChecked:
		case ExpressionType.NotEqual:
		case ExpressionType.Or:
		case ExpressionType.OrElse:
		case ExpressionType.Power:
		case ExpressionType.RightShift:
		case ExpressionType.Subtract:
		case ExpressionType.SubtractChecked:
		case ExpressionType.AddAssign:
		case ExpressionType.AndAssign:
		case ExpressionType.DivideAssign:
		case ExpressionType.ExclusiveOrAssign:
		case ExpressionType.LeftShiftAssign:
		case ExpressionType.ModuloAssign:
		case ExpressionType.MultiplyAssign:
		case ExpressionType.OrAssign:
		case ExpressionType.PowerAssign:
		case ExpressionType.RightShiftAssign:
		case ExpressionType.SubtractAssign:
		case ExpressionType.AddAssignChecked:
		case ExpressionType.MultiplyAssignChecked:
		case ExpressionType.SubtractAssignChecked:
			{
				var e = (BinaryExpression)expr;

				PushIndent("\t");

				GenerateExpr(e.Left);
				#>,<#+
				GenerateExpr(e.Right);

				PopIndent();

				break;
			}

		case ExpressionType.Convert:
		case ExpressionType.ConvertChecked:
			{
				var e = (UnaryExpression)expr;

				PushIndent("\t");

				GenerateExpr(e.Operand);
				#>,
				<#= TypeToString(e.Type) #><#+

				PopIndent();

				break;
			}

		case ExpressionType.ArrayLength:
		case ExpressionType.Negate:
		case ExpressionType.NegateChecked:
		case ExpressionType.Not:
		case ExpressionType.Quote:
		case ExpressionType.TypeAs:
		case ExpressionType.UnaryPlus:
		case ExpressionType.Decrement:
		case ExpressionType.Increment:
		case ExpressionType.IsFalse:
		case ExpressionType.IsTrue:
		case ExpressionType.Throw:
		case ExpressionType.Unbox:
		case ExpressionType.PreIncrementAssign:
		case ExpressionType.PreDecrementAssign:
		case ExpressionType.PostIncrementAssign:
		case ExpressionType.PostDecrementAssign:
		case ExpressionType.OnesComplement:
			{
				var e = (UnaryExpression)expr;

				PushIndent("\t");
				GenerateExpr(e.Operand);
				PopIndent();

				break;
			}

		case ExpressionType.Call:
			{
				var e = (MethodCallExpression)expr;

				PushIndent("\t");

				if (e.Object != null)
				{
					GenerateExpr(e.Object);
				}
				else
				{
				#>

				<#= TypeToString(e.Method.DeclaringType) #><#+
				}

				#>,
				"<#= e.Method.Name #>",
				new Type[0],
				<#+

				GenerateExprs(e.Arguments);

				PopIndent();

				break;
			}

		case ExpressionType.Conditional:
			{
				var e = (ConditionalExpression)expr;

				PushIndent("\t");

				GenerateExpr(e.Test);
				#>,<#+
				GenerateExpr(e.IfTrue);
				#>,<#+
				GenerateExpr(e.IfFalse);

				PopIndent();

				break;
			}

		case ExpressionType.Invoke:
			{
//				var e = (InvocationExpression)expr;
//
//				Visit(e.Expression, func);
//				Visit(e.Arguments,  func);

				break;
			}

		case ExpressionType.Lambda:
			{
//				var e = (LambdaExpression)expr;
//
//				Visit(e.Body,       func);
//				Visit(e.Parameters, func);

				break;
			}

		case ExpressionType.ListInit:
			{
//				var e = (ListInitExpression)expr;
//
//				Visit(e.NewExpression, func);
//				Visit(e.Initializers,  ex => Visit(ex.Arguments, func));

				break;
			}

		case ExpressionType.MemberAccess:
			{
				var e = (MemberExpression)expr;

				PushIndent("\t");

				GenerateExpr(e.Expression);

				if (e.Expression == null)
				{
				#>,
				<#= TypeToString(e.Member.DeclaringType) #><#+
				}

				#>,
				"<#= e.Member.Name #>"<#+

				PopIndent();

				break;
			}

		case ExpressionType.MemberInit:
			{
//				void MemberVisit(MemberBinding b)
//				{
//					switch (b.BindingType)
//					{
//						case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression,   func);                             break;
//						case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers, p => Visit(p.Arguments, func));    break;
//						case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings, (Action<MemberBinding>)MemberVisit); break;
//					}
//				}
//
//				var e = (MemberInitExpression)expr;
//
//				Visit(e.NewExpression, func);
//				Visit(e.Bindings,      (Action<MemberBinding>)MemberVisit);

				break;
			}

		case ExpressionType.New            :
			{
				var e = (NewExpression)expr;

				if (e.Arguments.Count == 0)
				{
				#><#= TypeToString(e.Type) #><#+
				}
				else
				{
					var indent = CurrentIndent;

					ClearIndent();

					var args = e.Arguments.Select(ex => TypeToString(ex.Type)).Aggregate((s1,s2) => $"{s1}, {s2}");

				#>

#if NETCOREAPP1_0 || NETCOREAPP1_1 || NETCOREAPP2_0 || NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2 || NETSTANDARD1_3 || NETSTANDARD1_4 || NETSTANDARD1_5 || NETSTANDARD1_6 || NETSTANDARD1_6
					<#= indent #><#= TypeToString(e.Type) #>.GetTypeInfo().GetConstructor(new[] { <#= args #> }),
#else
					<#= indent #><#= TypeToString(e.Type) #>.GetConstructor(new[] { <#= args #> }),
#endif
					<#= indent #><#+

					PushIndent(indent);
					PushIndent("\t");

					GenerateExprs(e.Arguments);

					PopIndent();
				}

				break;
			}

		case ExpressionType.NewArrayBounds :
//			Visit(((NewArrayExpression)  expr).Expressions, func);
			{
				var e = (NewArrayExpression)expr;

				if (e.Expressions.Count == 0)
				{
					#><#= TypeToString(e.Type).Replace("[]", "") #><#+
				}
				else
				{
					PushIndent("\t");

				#>

				<#= TypeToString(e.Type).Replace("[]", "") #>,
				<#+

					GenerateExprs(e.Expressions);

					PopIndent();
				}


				break;
			}

		case ExpressionType.NewArrayInit   :
			{
				var e = (NewArrayExpression)expr;

				if (e.Expressions.Count == 0)
				{
					#><#= TypeToString(e.Type).Replace("[]", "") #><#+
				}
				else
				{
					PushIndent("\t");

				#>

				<#= TypeToString(e.Type).Replace("[]", "") #>,
				<#+

					GenerateExprs(e.Expressions);

					PopIndent();
				}

				break;
			}


		case ExpressionType.TypeEqual      :
		case ExpressionType.TypeIs         :
			//Visit(((TypeBinaryExpression)expr).Expression,  func);
			break;

		case ExpressionType.Block:
			{
//				var e = (BlockExpression)expr;
//
//				Visit(e.Expressions, func);
//				Visit(e.Variables,   func);

				break;
			}

		case ExpressionType.Dynamic:
			{
//				var e = (DynamicExpression)expr;
//
//				Visit(e.Arguments, func);

				break;
			}

		case ExpressionType.Goto:
			{
//				var e = (GotoExpression)expr;
//
//				Visit(e.Value, func);

				break;
			}

		case ExpressionType.Index:
			{
//				var e = (IndexExpression)expr;
//
//				Visit(e.Object,    func);
//				Visit(e.Arguments, func);

				break;
			}

		case ExpressionType.Label:
			{
//				var e = (LabelExpression)expr;
//
//				Visit(e.DefaultValue, func);

				break;
			}

		case ExpressionType.RuntimeVariables:
			{
//				var e = (RuntimeVariablesExpression)expr;
//
//				Visit(e.Variables, func);

				break;
			}

		case ExpressionType.Loop:
			{
//				var e = (LoopExpression)expr;
//
//				Visit(e.Body, func);

				break;
			}

		case ExpressionType.Switch:
			{
//				var e = (SwitchExpression)expr;
//
//				Visit(e.SwitchValue, func);
//				Visit(e.Cases, cs => { Visit(cs.TestValues, func); Visit(cs.Body, func); });
//				Visit(e.DefaultBody, func);

				break;
			}

		case ExpressionType.Try:
			{
//				var e = (TryExpression)expr;
//
//				Visit(e.Body, func);
//				Visit(e.Handlers, h => { Visit(h.Variable, func); Visit(h.Filter, func); Visit(h.Body, func); });
//				Visit(e.Finally, func);
//				Visit(e.Fault, func);

				break;
			}

		case ExpressionType.Extension:
			{
//				if (expr.CanReduce)
//					Visit(expr.Reduce(), func);

				break;
			}

		case ExpressionType.Constant:
			{
				var c = (ConstantExpression)expr;

				#><#= ValueToString(c.Value) #>, <#= TypeToString(c.Type) #><#+

				break;
			}
	}

	#>)<#+
}
#>
